## Definitions
`intelligent_system (IS)` : the intelligent system (IS) generates a `skill program (S)` to do `task (T)` <br>
`task (T)`: a natural language prompt that forms an instruction to the machine what to do <br>
`skill program (S)`: a program or DAG generated by an `IS` to perform task `T` <br>
`curricula (C)`: data that the `IS` uses to train itself is denoted by `C` or Curricula, in our case all data in the train_array <br>
`curriculum item (C_n)` : `C_n` indicates a subset of the curriculum that is specific to a certain template/domain <br>
`domain (D)` : a related set of tasks/curricula. currently each template in our system can be it's own domain, but later we can group similar ones together into similar domains. <br>
`divergence_score (DS)` : distance between skill program created by a narrow rule-based generator, and a general-purpose `IS` <br>
`performance_theta (θ)` : performance of the `IS` on a task (`1 - DS`) <br>
`domain_distance_score` : fractional divergence/distance between any two given templates/domains/skill programs. `DS` can be used here too, if they are the same. <br>
`generalization_difficulty (GD)` : `domain_distance_score` between task domain & curricula domain (or training task and given test flow) <br>
`P(C_n)` : probability of finding curricula of domain type `C_n` in curricula. or (samples_of_template_C_n/total_number_C_samples) <br>
`priors (P)` : data which is built into the system _before_ training (are you fine-tuning something already fine-tuned?). This is negligible (~0) for most of current models. <br>
`experience (E)` : exposure of the `IS` to `Curricula` (tentative : compute * curricula?) <br>
`task_contribution` : contribution of performance on one `task (T)` to the overall `g_index` 
this is equal to, for any domain `C_n` in total n domains in curricula `C` - 
= `θ * Σ (P(C_n) * ( (GD(T,C_n)/(P + E(C_n)) )))` <br>
`tasks_scope` or `task_domains`: all the tasks/domains in the test array <br>
`g_index` :A measure of intelligence  average of task_contribution across all tasks_scope, :
`avg_across_T(θ * Σ (P(C_n) * ( (GD(T_i,C_n)/(P + E(C_n)) ))))` <br>
